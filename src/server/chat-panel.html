<style>
  .chat-panel {
    position: fixed;
    top: 0; right: 0; bottom: 0;
    width: 420px;
    z-index: 200;
    display: flex;
    flex-direction: column;
    background: #F3F4F6;
    border-left: 1px solid #ddd;
  }
  .chat-header {
    padding: 14px 20px;
    border-bottom: 1px solid #ddd;
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .chat-header h2 {
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 600;
    color: #333;
  }
  .chat-header button {
    background: none; border: none;
    color: #888; cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    padding: 4px 10px;
    border: 1px solid #ddd;
    border-radius: 4px;
    transition: all 0.15s;
  }
  .chat-header button:hover { color: #333; border-color: #999; }

  .chat-header select {
    font-family: 'Inter', sans-serif;
    font-size: 11px;
    color: #333;
    padding: 4px 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: #fff;
    cursor: pointer;
    outline: none;
    transition: border-color 0.15s;
  }
  .chat-header select:hover { border-color: #999; }
  .chat-header select:focus { border-color: #2a5a9a; }
  .chat-header-controls {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .chat-messages {
    flex: 1;
    overflow-y: auto;
    padding: 16px 20px;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  .chat-messages::-webkit-scrollbar { width: 4px; }
  .chat-messages::-webkit-scrollbar-thumb { background: #ccc; border-radius: 2px; }

  .chat-msg {
    padding: 10px 14px;
    border-radius: 10px;
    font-size: 13px;
    line-height: 1.5;
    max-width: 95%;
    word-wrap: break-word;
  }
  .chat-msg.user {
    background: #e3ecf7;
    color: #1a3a5c;
    align-self: flex-end;
    border-bottom-right-radius: 3px;
  }
  .chat-msg.assistant {
    background: #fff;
    color: #333;
    align-self: flex-start;
    border-bottom-left-radius: 3px;
    border: 1px solid #e0e0e0;
  }
  .chat-msg.assistant .sources {
    margin-top: 8px;
    padding-top: 8px;
    border-top: 1px solid #e8e8e8;
    font-size: 10px;
    color: #888;
    font-family: 'Inter', sans-serif;
  }
  .chat-msg.assistant .sources div {
    padding: 1px 0;
    cursor: pointer;
    color: #e67e22;
    transition: color 0.12s;
  }
  .chat-msg.assistant .sources div:hover { color: #d35400; }

  .chat-msg.system {
    background: transparent;
    color: #aaa;
    font-size: 11px;
    text-align: center;
    font-family: 'Inter', sans-serif;
    align-self: center;
    padding: 4px;
  }

  .chat-input-area {
    padding: 12px 20px 16px;
    border-top: 1px solid #ddd;
    display: flex;
    gap: 8px;
  }
  .chat-input-area input {
    flex: 1;
    padding: 10px 14px;
    border-radius: 8px;
    border: 1px solid #ddd;
    background: #fff;
    color: #333;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    outline: none;
    transition: border-color 0.2s;
  }
  .chat-input-area input:focus { border-color: #2a5a9a; }
  .chat-input-area input::placeholder { color: #bbb; }
  .chat-input-area button {
    padding: 10px 16px;
    border-radius: 8px;
    border: none;
    background: #2a5a9a;
    color: #fff;
    font-size: 13px;
    cursor: pointer;
    font-family: 'Inter', sans-serif;
    font-weight: 500;
    transition: background 0.15s;
  }
  .chat-input-area button:hover { background: #3a7bd5; }
  .chat-input-area button:disabled { opacity: 0.4; cursor: not-allowed; }

  .typing-indicator {
    display: none;
    align-self: flex-start;
    padding: 8px 14px;
    font-size: 12px;
    color: #999;
    font-family: 'Inter', sans-serif;
  }
  .typing-indicator.visible { display: block; }
  .typing-indicator span {
    animation: blink 1.4s infinite;
  }
  .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
  .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
  @keyframes blink { 0%,60%,100% { opacity: 0.2; } 30% { opacity: 1; } }

  .mic-btn {
    padding: 10px 12px;
    border-radius: 8px;
    border: 1px solid #ddd;
    background: #fff;
    color: #888;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
    flex-shrink: 0;
  }
  .mic-btn svg { width: 16px; height: 16px; }
  .mic-btn:hover { color: #333; border-color: #999; }
  .mic-btn.recording {
    background: #e74c3c;
    border-color: #c0392b;
    color: #fff;
    animation: pulse 1.5s ease-in-out infinite;
  }
  .mic-btn.processing {
    background: #f39c12;
    border-color: #e67e22;
    color: #fff;
    opacity: 0.7;
    cursor: wait;
  }
  @keyframes pulse {
    0%, 100% { box-shadow: 0 0 0 0 rgba(231,76,60,0.4); }
    50% { box-shadow: 0 0 0 8px rgba(231,76,60,0); }
  }

  .speaker-btn {
    background: none; border: none;
    color: #888; cursor: pointer;
    padding: 4px 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    transition: all 0.15s;
    display: flex;
    align-items: center;
  }
  .speaker-btn svg { width: 14px; height: 14px; }
  .speaker-btn:hover { color: #333; border-color: #999; }
  .speaker-btn.active { color: #2a5a9a; border-color: #2a5a9a; }

  /* Adjust graph area for chat panel */
  #graph-container { left: 280px; right: 420px; }
  .control-panel { z-index: 50; }
</style>

<div class="chat-panel">
  <div class="chat-header">
    <h2>Knowledge</h2>
    <div class="chat-header-controls">
      <select id="index-selector" onchange="switchIndex(this.value)"></select>
      <button class="speaker-btn" id="speaker-toggle" onclick="toggleTts()" title="Toggle voice output"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15" class="speaker-off"/><line x1="17" y1="9" x2="23" y2="15" class="speaker-off"/></svg></button>
      <button onclick="clearChat()">Clear</button>
    </div>
  </div>
  <div class="chat-messages" id="chat-messages">
    <div class="chat-msg system" id="chat-welcome">Ask a question about the knowledge base</div>
  </div>
  <div class="typing-indicator" id="typing">
    Searching<span>.</span><span>.</span><span>.</span>
  </div>
  <div class="chat-input-area">
    <input type="text" id="chat-input" placeholder="Ask a question..." />
    <button class="mic-btn" id="mic-btn" onclick="toggleMic()" title="Voice input"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="23"/><line x1="8" y1="23" x2="16" y2="23"/></svg></button>
    <button id="chat-send" onclick="sendMessage()">Ask</button>
  </div>
</div>

<script>
// ── Chat Logic ──────────────────────────────────────────

const chatInput = document.getElementById('chat-input');
const chatMessages = document.getElementById('chat-messages');
const chatSend = document.getElementById('chat-send');
const typingEl = document.getElementById('typing');
const indexSelector = document.getElementById('index-selector');

// Load available indexes on startup
(async function loadIndexes() {
  try {
    const resp = await fetch('/api/indexes');
    const indexes = await resp.json();
    indexSelector.innerHTML = '';
    let activeName = '';
    for (const idx of indexes) {
      const opt = document.createElement('option');
      opt.value = idx.name;
      opt.textContent = idx.name + ' (' + idx.chunks + ' chunks)';
      if (idx.active) { opt.selected = true; activeName = idx.name; }
      indexSelector.appendChild(opt);
    }
    const welcome = document.getElementById('chat-welcome');
    if (welcome && activeName) welcome.textContent = 'Ask a question about ' + activeName;
  } catch (e) {
    console.error('Failed to load indexes:', e);
  }
})();

async function switchIndex(name) {
  chatSend.disabled = true;
  indexSelector.disabled = true;
  addMessage('system', 'Switching to ' + name + '...');
  try {
    const resp = await fetch('/api/switch', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ index: name }),
    });
    const data = await resp.json();
    if (data.error) {
      addMessage('system', 'Error: ' + data.error);
    } else {
      // Reload graph with new viz data
      if (data.vizData && typeof initGraph === 'function') {
        initGraph(data.vizData);
      }
      chatMessages.innerHTML = '';
      addMessage('system', 'Ask a question about ' + name);
    }
  } catch (e) {
    addMessage('system', 'Switch failed: ' + e.message);
  }
  chatSend.disabled = false;
  indexSelector.disabled = false;
}

chatInput.addEventListener('keydown', e => {
  if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); sendMessage(); }
});

async function sendMessage() {
  const query = chatInput.value.trim();
  if (!query) return;

  chatInput.value = '';
  chatSend.disabled = true;

  // Add user message
  addMessage('user', query);

  // Show typing
  typingEl.classList.add('visible');
  chatMessages.scrollTop = chatMessages.scrollHeight;

  try {
    const resp = await fetch('/api/ask-stream', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ query }),
    });

    if (!resp.ok) {
      const err = await resp.json().catch(() => ({ error: resp.statusText }));
      typingEl.classList.remove('visible');
      addMessage('system', 'Error: ' + (err.error || resp.statusText));
      chatSend.disabled = false;
      return;
    }

    // Create the assistant message div for streaming into
    const msgDiv = document.createElement('div');
    msgDiv.className = 'chat-msg assistant';
    chatMessages.appendChild(msgDiv);
    typingEl.classList.remove('visible');

    let fullAnswer = '';
    let sources = [];
    let vizPath = null;

    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let eventType = '';

    function processSSELines(lines) {
      for (const line of lines) {
        if (line.startsWith('event: ')) {
          eventType = line.slice(7).trim();
        } else if (line.startsWith('data: ')) {
          const data = line.slice(6);
          try {
            const parsed = JSON.parse(data);
            if (eventType === 'sources') {
              sources = parsed;
            } else if (eventType === 'token') {
              fullAnswer += parsed;
              msgDiv.innerHTML = formatAnswer(fullAnswer);
              chatMessages.scrollTop = chatMessages.scrollHeight;
              onStreamToken(parsed);
            } else if (eventType === 'done') {
              vizPath = parsed.path;
            } else if (eventType === 'error') {
              addMessage('system', 'Error: ' + parsed.error);
            }
          } catch (e) { /* skip malformed */ }
          eventType = '';
        }
      }
    }

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';
      processSSELines(lines);
    }

    // Process any remaining data in the buffer
    if (buffer.trim()) {
      processSSELines(buffer.split('\n'));
    }

    // Final render with sources
    let sourcesHtml = '';
    if (sources.length > 0) {
      sourcesHtml = '<div class="sources">' +
        sources.map(s => {
          const pg = s.pageStart === s.pageEnd ? 'p.' + s.pageStart : 'pp.' + s.pageStart + '-' + s.pageEnd;
          const label = s.file.replace(/\.md$/, '').split('/').pop();
          if (s.url) {
            return '<div data-doc="doc:' + s.file.replace(/"/g, '&quot;') + '" data-url="' + s.url.replace(/"/g, '&quot;') + '">[' + s.index + '] ' + label + ' (' + pg + ') ↗</div>';
          }
          return '<div data-doc="doc:' + s.file.replace(/"/g, '&quot;') + '">[' + s.index + '] ' + label + ' (' + pg + ')</div>';
        }).join('') +
        '</div>';
    }
    msgDiv.innerHTML = formatAnswer(fullAnswer) + sourcesHtml;

    // Highlight graph path
    if (vizPath && typeof highlightPath === 'function') {
      highlightPath(vizPath);
    }

    // Flush any remaining TTS text
    flushTtsBuffer();

  } catch (e) {
    typingEl.classList.remove('visible');
    addMessage('system', 'Connection error: ' + e.message);
  }

  chatSend.disabled = false;
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

function formatAnswer(text) {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/\[Source (\d+)\]/g, '<strong style="color:#e67e22">[Source $1]</strong>')
    .replace(/\n/g, '<br>');
}

function addMessage(role, text, extraHtml = '') {
  const div = document.createElement('div');
  div.className = 'chat-msg ' + role;
  // Simple markdown-like formatting
  let html = text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/\[Source (\d+)\]/g, '<strong style="color:#e67e22">[Source $1]</strong>')
    .replace(/\n/g, '<br>');
  div.innerHTML = html + extraHtml;
  chatMessages.appendChild(div);
  chatMessages.scrollTop = chatMessages.scrollHeight;
}

// Event delegation for source clicks — open URL if available, else focus graph node
chatMessages.addEventListener('click', function(e) {
  const sourceEl = e.target.closest('[data-doc]');
  if (sourceEl) {
    if (sourceEl.dataset.url) {
      window.open(sourceEl.dataset.url, '_blank');
    } else {
      focusNode(sourceEl.dataset.doc);
    }
  }
});

function clearChat() {
  stopAudio();
  chatMessages.innerHTML = '';
  const name = indexSelector.value || 'the knowledge base';
  chatMessages.innerHTML = '<div class="chat-msg system" id="chat-welcome">Ask a question about ' + name + '</div>';
  fetch('/api/forget', { method: 'POST' });
  if (typeof clearPath === 'function') clearPath();
}

// highlightPath and focusNode are defined in graph-viz.html (vis-network)
// No need to redefine them here.

// ── Voice: STT (Web Speech API) + TTS (Amazon Polly) ─────

const micBtn = document.getElementById('mic-btn');
const speakerBtn = document.getElementById('speaker-toggle');

let ttsEnabled = false;
let currentAudio = null;
let sttRecognition = null;

const speakerSvgOff = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><line x1="23" y1="9" x2="17" y2="15"/><line x1="17" y1="9" x2="23" y2="15"/></svg>';
const speakerSvgOn = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/><path d="M19.07 4.93a10 10 0 0 1 0 14.14"/><path d="M15.54 8.46a5 5 0 0 1 0 7.07"/></svg>';

function toggleTts() {
  ttsEnabled = !ttsEnabled;
  speakerBtn.classList.toggle('active', ttsEnabled);
  speakerBtn.innerHTML = ttsEnabled ? speakerSvgOn : speakerSvgOff;
  if (!ttsEnabled) stopAudio();
}

function stopAudio() {
  if (currentAudio) {
    currentAudio.pause();
    currentAudio = null;
  }
  ttsAudioQueue = [];
  ttsIsPlaying = false;
  ttsBuffer = '';
}

// ── STT: Browser Web Speech API ──────────────────────────

function toggleMic() {
  if (sttRecognition) {
    sttRecognition.stop();
    sttRecognition = null;
    micBtn.classList.remove('recording');
    chatInput.placeholder = 'Ask a question...';
    return;
  }

  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if (!SpeechRecognition) {
    addMessage('system', 'Voice input not available in this browser');
    return;
  }

  stopAudio();
  sttRecognition = new SpeechRecognition();
  sttRecognition.lang = 'en-AU';
  sttRecognition.interimResults = true;
  sttRecognition.maxAlternatives = 1;

  micBtn.classList.add('recording');
  chatInput.placeholder = 'Listening...';

  sttRecognition.onresult = (event) => {
    let transcript = '';
    for (let i = 0; i < event.results.length; i++) {
      transcript += event.results[i][0].transcript;
    }
    chatInput.value = transcript;
    if (event.results[event.results.length - 1].isFinal) {
      micBtn.classList.remove('recording');
      chatInput.placeholder = 'Ask a question...';
      sttRecognition = null;
      if (chatInput.value.trim()) sendMessage();
    }
  };

  sttRecognition.onerror = () => {
    micBtn.classList.remove('recording');
    chatInput.placeholder = 'Ask a question...';
    sttRecognition = null;
    addMessage('system', 'Voice recognition failed');
  };

  sttRecognition.onend = () => {
    micBtn.classList.remove('recording');
    chatInput.placeholder = 'Ask a question...';
    sttRecognition = null;
  };

  sttRecognition.start();
}

// ── TTS: Amazon Polly (sentence-by-sentence streaming) ───

let ttsBuffer = '';
let ttsAudioQueue = [];
let ttsIsPlaying = false;
let lastSpokenText = '';

function cleanTtsText(t) {
  return t.replace(/\[Source \d+\]/g, '').replace(/\*\*(.+?)\*\*/g, '$1').trim();
}

function onStreamToken(token) {
  if (!ttsEnabled) return;
  ttsBuffer += token;
  let match;
  while ((match = ttsBuffer.match(/^([\s\S]*?[.!?])\s/))) {
    const sentence = cleanTtsText(match[1]);
    ttsBuffer = ttsBuffer.slice(match[0].length);
    if (sentence) enqueueTts(sentence);
  }
}

function flushTtsBuffer() {
  if (!ttsEnabled) return;
  const remaining = cleanTtsText(ttsBuffer);
  ttsBuffer = '';
  if (remaining) enqueueTts(remaining);
}

async function enqueueTts(text) {
  try {
    const resp = await fetch('/api/tts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ text }),
    });
    const data = await resp.json();
    if (data.audioContent) {
      const audioSrc = 'data:audio/mp3;base64,' + data.audioContent;
      ttsAudioQueue.push(audioSrc);
      playNextTts();
    }
  } catch (e) {
    // Silent fail on TTS errors
  }
}

function playNextTts() {
  if (ttsIsPlaying || ttsAudioQueue.length === 0) return;
  ttsIsPlaying = true;
  const src = ttsAudioQueue.shift();
  currentAudio = new Audio(src);
  currentAudio.onended = () => {
    currentAudio = null;
    ttsIsPlaying = false;
    playNextTts();
  };
  currentAudio.onerror = () => {
    currentAudio = null;
    ttsIsPlaying = false;
    playNextTts();
  };
  currentAudio.play();
}
</script>
