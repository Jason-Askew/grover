<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Knowledge Graph</title>
<script src="https://unpkg.com/vis-network@9.1.6/standalone/umd/vis-network.min.js"></script>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #F3F4F6;
    color: #333;
    font-family: 'Inter', sans-serif;
    overflow: hidden;
    height: 100vh;
  }

  /* ── Control panel (left) ── */
  .control-panel {
    position: absolute;
    top: 0; left: 0; bottom: 0;
    width: 280px;
    background: #fff;
    border-right: 1px solid #e0e0e0;
    display: flex;
    flex-direction: column;
    z-index: 50;
    overflow: hidden;
    transition: width 0.25s ease;
  }
  .control-panel.collapsed {
    width: 40px;
  }
  .control-panel.collapsed .cp-body,
  .control-panel.collapsed .cp-header span {
    display: none;
  }
  .cp-collapse-btn {
    background: none; border: none; cursor: pointer; padding: 4px;
    color: #666; font-size: 16px; line-height: 1; flex-shrink: 0;
  }
  .cp-collapse-btn:hover { color: #333; }
  .cp-header {
    padding: 14px 16px;
    border-bottom: 1px solid #e8e8e8;
    font-size: 13px;
    font-weight: 600;
    color: #333;
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
  }
  .control-panel.collapsed .cp-header {
    justify-content: center;
    padding: 14px 8px;
    border-bottom: none;
  }
  .cp-header .cp-stats { font-weight: 400; font-size: 11px; color: #999; }
  .cp-body {
    flex: 1;
    overflow-y: auto;
    padding-bottom: 12px;
  }
  .cp-body::-webkit-scrollbar { width: 4px; }
  .cp-body::-webkit-scrollbar-thumb { background: #ddd; border-radius: 2px; }

  /* ── Section ── */
  .cp-section {
    border-bottom: 1px solid #f0f0f0;
  }
  .cp-section-header {
    display: flex;
    align-items: center;
    padding: 10px 16px;
    cursor: pointer;
    user-select: none;
    gap: 8px;
    transition: background 0.1s;
  }
  .cp-section-header:hover { background: #f8f9fa; }
  .cp-section-header .cp-chevron {
    font-size: 10px; color: #aaa;
    transition: transform 0.2s;
    width: 12px; text-align: center;
    flex-shrink: 0;
  }
  .cp-section.open .cp-chevron { transform: rotate(90deg); }
  .cp-section-header .cp-dot {
    width: 10px; height: 10px;
    border-radius: 50%; flex-shrink: 0;
  }
  .cp-section-header .cp-section-label {
    flex: 1; font-size: 12px; font-weight: 500;
  }
  .cp-section-header .cp-count {
    font-size: 10px; color: #aaa; flex-shrink: 0;
  }
  .cp-toggle {
    width: 30px; height: 16px;
    border-radius: 8px;
    background: #ddd;
    position: relative;
    cursor: pointer;
    transition: background 0.2s;
    flex-shrink: 0;
  }
  .cp-toggle.on { background: #4a8eda; }
  .cp-toggle::after {
    content: '';
    position: absolute;
    top: 2px; left: 2px;
    width: 12px; height: 12px;
    border-radius: 50%;
    background: #fff;
    transition: transform 0.2s;
    box-shadow: 0 1px 2px rgba(0,0,0,0.15);
  }
  .cp-toggle.on::after { transform: translateX(14px); }

  /* ── Value list ── */
  .cp-values {
    display: none;
    padding: 0 16px 8px;
  }
  .cp-section.open .cp-values { display: block; }
  .cp-filter-input {
    width: 100%;
    padding: 5px 8px;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    font-size: 11px;
    outline: none;
    margin-bottom: 6px;
    color: #333;
    background: #fafafa;
  }
  .cp-filter-input:focus { border-color: #4a8eda; }
  .cp-filter-input::placeholder { color: #bbb; }
  .cp-value-list {
    max-height: 200px;
    overflow-y: auto;
  }
  .cp-value-list::-webkit-scrollbar { width: 3px; }
  .cp-value-list::-webkit-scrollbar-thumb { background: #e0e0e0; border-radius: 2px; }
  .cp-value-item {
    display: flex;
    align-items: center;
    gap: 6px;
    padding: 3px 0;
    font-size: 11px;
    color: #555;
    cursor: pointer;
    user-select: none;
  }
  .cp-value-item:hover { color: #111; }
  .cp-value-item .cp-check {
    width: 14px; height: 14px;
    border-radius: 3px;
    border: 1px solid #ccc;
    display: flex; align-items: center; justify-content: center;
    font-size: 9px; color: #fff;
    flex-shrink: 0;
    transition: all 0.15s;
  }
  .cp-value-item.on .cp-check {
    background: #4a8eda;
    border-color: #3a7bd5;
  }
  .cp-value-item .cp-value-label {
    flex: 1;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .cp-value-item.unavailable {
    opacity: 0.25;
    pointer-events: none;
  }
  .cp-select-all {
    font-size: 10px;
    color: #4a8eda;
    cursor: pointer;
    margin-bottom: 4px;
    display: inline-block;
  }
  .cp-select-all:hover { text-decoration: underline; }

  /* ── Relationship sections ── */
  .cp-divider {
    padding: 8px 16px 4px;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: #aaa;
    background: #fafafa;
    border-bottom: 1px solid #f0f0f0;
  }

  /* ── Graph container ── */
  #graph-container {
    position: absolute;
    top: 0; left: 280px; bottom: 0; right: 420px;
    background: #F3F4F6;
  }
  #graph-container > div { width: 100%; height: 100%; }

  /* Document viewer panel */
  .doc-viewer {
    position: fixed;
    top: 0; bottom: 0;
    left: 280px;
    width: 480px;
    z-index: 150;
    background: #fff;
    border-right: 1px solid #e0e0e0;
    display: none;
    flex-direction: column;
    box-shadow: 4px 0 20px rgba(0,0,0,0.08);
  }
  .doc-viewer.visible { display: flex; }
  .doc-viewer-header {
    padding: 14px 16px;
    border-bottom: 1px solid #e8e8e8;
    flex-shrink: 0;
  }
  .doc-viewer-header h3 {
    font-family: 'Inter', sans-serif;
    font-size: 14px;
    font-weight: 600;
    color: #333;
    margin-bottom: 4px;
    line-height: 1.4;
  }
  .doc-viewer-header .doc-url {
    font-size: 11px;
    font-family: 'Inter', sans-serif;
  }
  .doc-viewer-header .doc-url a {
    color: #e67e22;
    text-decoration: none;
    transition: color 0.15s;
  }
  .doc-viewer-header .doc-url a:hover { color: #d35400; text-decoration: underline; }
  .doc-viewer-header .doc-meta {
    font-size: 11px;
    color: #999;
    font-family: 'Inter', sans-serif;
    margin-top: 4px;
  }
  .doc-viewer-close {
    position: absolute; top: 10px; right: 12px;
    background: none; border: 1px solid #ddd;
    border-radius: 4px; padding: 2px 8px;
    font-size: 14px; cursor: pointer; color: #888;
    font-family: 'Inter', sans-serif;
    transition: all 0.15s;
  }
  .doc-viewer-close:hover { color: #333; border-color: #999; }
  .doc-viewer-body {
    flex: 1;
    overflow-y: auto;
    padding: 16px;
    font-family: 'Inter', sans-serif;
    font-size: 13px;
    line-height: 1.7;
    color: #444;
  }
  .doc-viewer-body::-webkit-scrollbar { width: 4px; }
  .doc-viewer-body::-webkit-scrollbar-thumb { background: #ddd; border-radius: 2px; }
  .doc-viewer-body h1,.doc-viewer-body h2,.doc-viewer-body h3 {
    color: #222; margin: 16px 0 8px; font-weight: 600;
  }
  .doc-viewer-body h1 { font-size: 18px; }
  .doc-viewer-body h2 { font-size: 15px; }
  .doc-viewer-body h3 { font-size: 13px; }
  .doc-viewer-body p { margin-bottom: 10px; }
  .doc-viewer-body ul,.doc-viewer-body ol { margin: 8px 0 8px 20px; }
  .doc-viewer-body li { margin-bottom: 4px; }
  .doc-viewer-loading {
    display: flex; align-items: center; justify-content: center;
    height: 100%; color: #999; font-size: 13px;
  }

  /* ── Memory viewer panel ── */
  .memory-viewer {
    position: fixed;
    top: 0; bottom: 0;
    left: 280px;
    width: 480px;
    z-index: 150;
    background: #fff;
    border-right: 1px solid #e0e0e0;
    display: none;
    flex-direction: column;
    box-shadow: 4px 0 20px rgba(0,0,0,0.08);
  }
  .memory-viewer.visible { display: flex; }
  .memory-viewer-header {
    padding: 14px 16px;
    border-bottom: 1px solid #e8e8e8;
    flex-shrink: 0;
  }
  .memory-viewer-header h3 {
    font-family: 'Inter', sans-serif;
    font-size: 14px; font-weight: 600; color: #333;
    margin-bottom: 2px; line-height: 1.4;
  }
  .memory-viewer-header .memory-count {
    font-size: 11px; color: #999; font-family: 'Inter', sans-serif;
  }
  .memory-viewer-close {
    position: absolute; top: 10px; right: 12px;
    background: none; border: 1px solid #ddd;
    border-radius: 4px; padding: 2px 8px;
    font-size: 14px; cursor: pointer; color: #888;
    font-family: 'Inter', sans-serif;
    transition: all 0.15s;
  }
  .memory-viewer-close:hover { color: #333; border-color: #999; }
  .memory-viewer-body {
    flex: 1; overflow-y: auto; padding: 12px 16px;
    font-family: 'Inter', sans-serif;
  }
  .memory-viewer-body::-webkit-scrollbar { width: 4px; }
  .memory-viewer-body::-webkit-scrollbar-thumb { background: #ddd; border-radius: 2px; }
  .memory-card {
    border: 1px solid #e8e8e8; border-radius: 6px;
    padding: 12px; margin-bottom: 10px;
    background: #fafafa;
  }
  .memory-card-time {
    font-size: 10px; color: #aaa; margin-bottom: 6px;
  }
  .memory-card-q {
    font-size: 12px; font-weight: 600; color: #333; margin-bottom: 4px;
  }
  .memory-card-a {
    font-size: 12px; color: #555; line-height: 1.6; margin-bottom: 6px;
  }
  .memory-card-a p { margin-bottom: 6px; }
  .memory-card-a h1,.memory-card-a h2,.memory-card-a h3 {
    color: #222; margin: 8px 0 4px; font-weight: 600;
  }
  .memory-card-a h1 { font-size: 15px; }
  .memory-card-a h2 { font-size: 13px; }
  .memory-card-a h3 { font-size: 12px; }
  .memory-card-sources {
    font-size: 10px; color: #999;
  }
  .memory-card-sources span {
    display: inline-block; background: #eee; border-radius: 3px;
    padding: 1px 5px; margin: 1px 2px;
  }
  .cp-memory-btn {
    background: none; border: 1px solid #ddd; border-radius: 4px;
    padding: 2px 8px; font-size: 11px; cursor: pointer; color: #666;
    font-family: 'Inter', sans-serif; transition: all 0.15s;
    margin-right: 4px;
  }
  .cp-memory-btn:hover { color: #333; border-color: #999; }
  .cp-memory-btn.active {
    background: #4a8eda; color: #fff; border-color: #3a7bd5;
  }
  .cp-memory-btn.active:hover { background: #3a7bd5; }


  .loading {
    position: fixed; inset: 0; z-index: 500;
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    background: #F3F4F6; gap: 16px; transition: opacity 0.5s;
  }
  .loading.hidden { opacity: 0; pointer-events: none; }
  .loading-spinner {
    width: 36px; height: 36px;
    border: 2px solid #ddd; border-top-color: #888;
    border-radius: 50%; animation: spin 0.8s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
  .loading-text { font-size: 13px; color: #888; }
</style>
</head>
<body>

<div class="loading" id="loading">
  <div class="loading-spinner"></div>
  <div class="loading-text">Initializing graph...</div>
</div>

<!-- Left control panel -->
<div class="control-panel" id="control-panel">
  <div class="cp-header">
    <span>Filters</span>
    <span class="cp-stats" id="cp-stats"></span>
    <button class="cp-memory-btn" id="cp-memory-btn" onclick="toggleMemoryGraph()" title="Toggle memory graph">Memory</button>
    <button class="cp-collapse-btn" id="cp-collapse-btn" onclick="toggleFilterPanel()" title="Collapse filters">&#9664;</button>
  </div>
  <div class="cp-body" id="cp-body">
    <!-- populated by JS -->
  </div>
</div>

<div id="graph-container">
  <div id="vis-canvas"></div>

  <span id="node-tooltip" style="position:absolute;z-index:100;background:rgba(0,0,0,0.75);color:#fff;padding:2px 6px;border-radius:2px;font-size:10px;line-height:1;display:none;pointer-events:none;white-space:nowrap;font-family:Inter,sans-serif;" role="tooltip"></span>

</div>

<div class="memory-viewer" id="memory-viewer">
  <button class="memory-viewer-close" onclick="closeMemoryViewer()">×</button>
  <div class="memory-viewer-header">
    <h3>Conversation Memory</h3>
    <div class="memory-count" id="memory-count"></div>
  </div>
  <div class="memory-viewer-body" id="memory-viewer-body">
    <div class="doc-viewer-loading">Loading...</div>
  </div>
</div>

<div class="doc-viewer" id="doc-viewer">
  <button class="doc-viewer-close" onclick="closeDocViewer()">×</button>
  <div class="doc-viewer-header">
    <h3 id="doc-viewer-title">Document</h3>
    <div class="doc-url" id="doc-viewer-url"></div>
    <div class="doc-meta" id="doc-viewer-meta"></div>
  </div>
  <div class="doc-viewer-body" id="doc-viewer-body">
    <div class="doc-viewer-loading">Click a document node to view its contents</div>
  </div>
</div>

<script>
// ── Brand themes ────────────────────────────────────
const BRAND_THEMES = {
  wbc: { label: 'Westpac', primary: '#D52B1E', secondary: '#E34A2B',
    colors: { brand:{bg:'#D52B1E',size:60},category:{bg:'#ED6758',size:60},document:{bg:'#F18285',size:20},product:{bg:'#F99DAF',size:40},concept:{bg:'#FFB7D2',size:30} },
    edges: { belongs_to_brand:'#D52B1E',in_category:'#E34A2B',mentions:'#F18285' } },
  sgb: { label: 'St.George', primary: '#00853E', secondary: '#00A64F',
    colors: { brand:{bg:'#00853E',size:60},category:{bg:'#33A066',size:60},document:{bg:'#66BB8E',size:20},product:{bg:'#99D5B5',size:40},concept:{bg:'#BFE9C1',size:30} },
    edges: { belongs_to_brand:'#00853E',in_category:'#00A64F',mentions:'#66BB8E' } },
  bom: { label: 'Bank of Melbourne', primary: '#6A1B9A', secondary: '#8E24AA',
    colors: { brand:{bg:'#6A1B9A',size:60},category:{bg:'#8844AA',size:60},document:{bg:'#A66DC0',size:20},product:{bg:'#C496D6',size:40},concept:{bg:'#D1C4E9',size:30} },
    edges: { belongs_to_brand:'#6A1B9A',in_category:'#8E24AA',mentions:'#A66DC0' } },
  bsa: { label: 'BankSA', primary: '#00AEEF', secondary: '#0077C8',
    colors: { brand:{bg:'#00AEEF',size:60},category:{bg:'#33BBEE',size:60},document:{bg:'#66CCEE',size:20},product:{bg:'#99DDEE',size:40},concept:{bg:'#B3E5FC',size:30} },
    edges: { belongs_to_brand:'#00AEEF',in_category:'#0077C8',mentions:'#66CCEE' } },
};
const DEFAULT_COLORS = { brand:{bg:'#555',size:60},category:{bg:'#777',size:60},document:{bg:'#999',size:20},product:{bg:'#AAA',size:40},concept:{bg:'#BBB',size:30} };
const MATCH_COLOR = '#f0c850';

function toggleFilterPanel() {
  const panel = document.getElementById('control-panel');
  const btn = document.getElementById('cp-collapse-btn');
  panel.classList.toggle('collapsed');
  const collapsed = panel.classList.contains('collapsed');
  btn.innerHTML = collapsed ? '&#9654;' : '&#9664;';
  btn.title = collapsed ? 'Expand filters' : 'Collapse filters';
}

const NODE_TYPE_META = {
  brand:    { label: 'Services',   color: '#e86c5f' },
  category: { label: 'Categories', color: '#e8a84c' },
  document: { label: 'Documents',  color: '#4a8eda' },
  product:  { label: 'Products',   color: '#6dd490' },
  concept:  { label: 'Concepts',   color: '#b07de8' },
};

const EDGE_TYPE_META = {
  belongs_to_brand:    { label: 'service',   color: '#e86c5f' },
  in_category:         { label: 'category',  color: '#e8a84c' },
  mentions:            { label: 'mentions',  color: '#6dd490' },
  semantically_similar:{ label: 'similar',   color: '#4a8eda' },
  shared_concept:      { label: 'shared',    color: '#b07de8' },
};

let graphData = null, network = null, visNodes = null, visEdges = null;
let allVisNodes = [], allVisEdges = [], matchedDocIds = new Set();
let visNodeById = {}; // O(1) node lookup by id

// Filter state
let filterState = {
  nodeTypes: {},   // type -> boolean
  edgeTypes: {},   // type -> boolean
  nodeValues: {},  // type -> { value -> boolean }
};

// ── Init ────────────────────────────────────────────

// Precomputed adjacency: nodeId -> Set of connected nodeIds
let adjacency = {};

function initGraph(data) {
  graphData = data;
  document.getElementById('loading').classList.add('hidden');
  data.nodeMap = {};
  data.nodes.forEach(n => { data.nodeMap[n.id] = n; });

  // Build adjacency index for cascading filters
  adjacency = {};
  for (const n of data.nodes) adjacency[n.id] = new Set();
  for (const e of data.edges) {
    if (adjacency[e.source]) adjacency[e.source].add(e.target);
    if (adjacency[e.target]) adjacency[e.target].add(e.source);
  }

  initFilterState(data);
  buildControlPanel(data);
  buildNetwork(data);
  updateStats();
}

function initFilterState(data) {
  // Node types
  const nodeTypes = new Set(data.nodes.map(n => n.type));
  nodeTypes.forEach(t => {
    filterState.nodeTypes[t] = true;
    filterState.nodeValues[t] = {};
  });

  // Collect unique values per type
  data.nodes.forEach(n => {
    const label = n.type === 'document'
      ? n.label.split('/').pop().replace('.pdf','')
      : n.label;
    filterState.nodeValues[n.type][n.id] = { label, fullLabel: n.label, enabled: true };
  });

  // Edge types
  const edgeTypes = new Set(data.edges.map(e => e.type));
  edgeTypes.forEach(t => { filterState.edgeTypes[t] = true; });
}

// ── Control Panel ───────────────────────────────────

function buildControlPanel(data) {
  const body = document.getElementById('cp-body');
  let html = '';

  // Node type sections
  html += '<div class="cp-divider">Node Types</div>';
  const typeOrder = ['brand','category','document','product','concept'];
  for (const type of typeOrder) {
    if (!filterState.nodeValues[type]) continue;
    const meta = NODE_TYPE_META[type] || { label: type, color: '#888' };
    const values = Object.entries(filterState.nodeValues[type]);
    values.sort((a,b) => a[1].label.localeCompare(b[1].label));

    html += `<div class="cp-section open" data-section="node-${type}">`;
    html += `<div class="cp-section-header" onclick="toggleSection(this)">`;
    html += `<span class="cp-chevron">▶</span>`;
    html += `<span class="cp-dot" style="background:${meta.color}"></span>`;
    html += `<span class="cp-section-label">${meta.label}</span>`;
    html += `<span class="cp-count">${values.length}</span>`;
    html += `<div class="cp-toggle on" onclick="event.stopPropagation();toggleNodeType('${type}',this)"></div>`;
    html += `</div>`;
    html += `<div class="cp-values">`;
    html += `<input class="cp-filter-input" placeholder="Filter ${meta.label.toLowerCase()}..." oninput="filterValues('${type}',this.value)" />`;
    html += `<span class="cp-select-all" onclick="selectAllValues('${type}',true)">All</span> · `;
    html += `<span class="cp-select-all" onclick="selectAllValues('${type}',false)">None</span>`;
    html += `<div class="cp-value-list" id="values-${type}">`;
    for (const [id, v] of values) {
      html += `<div class="cp-value-item on" data-id="${id}" data-type="${type}" onclick="toggleValue(this,'${type}','${id}')">`;
      html += `<div class="cp-check">✓</div>`;
      html += `<span class="cp-value-label" title="${v.fullLabel}">${v.label}</span>`;
      html += `</div>`;
    }
    html += `</div></div></div>`;
  }

  // Edge type sections
  html += '<div class="cp-divider">Relationship Types</div>';
  for (const [type, enabled] of Object.entries(filterState.edgeTypes)) {
    const meta = EDGE_TYPE_META[type] || { label: type, color: '#aaa' };
    const count = data.edges.filter(e => e.type === type).length;
    html += `<div class="cp-section" data-section="edge-${type}">`;
    html += `<div class="cp-section-header">`;
    html += `<span class="cp-chevron" style="visibility:hidden">▶</span>`;
    html += `<span class="cp-dot" style="background:${meta.color}"></span>`;
    html += `<span class="cp-section-label">${meta.label}</span>`;
    html += `<span class="cp-count">${count}</span>`;
    html += `<div class="cp-toggle on" onclick="event.stopPropagation();toggleEdgeType('${type}',this)"></div>`;
    html += `</div></div>`;
  }

  body.innerHTML = html;
}

function toggleSection(headerEl) {
  headerEl.parentElement.classList.toggle('open');
}

function toggleNodeType(type, toggleEl) {
  filterState.nodeTypes[type] = !filterState.nodeTypes[type];
  toggleEl.classList.toggle('on', filterState.nodeTypes[type]);

  // Also toggle all values
  for (const id of Object.keys(filterState.nodeValues[type])) {
    filterState.nodeValues[type][id].enabled = filterState.nodeTypes[type];
  }
  // Update checkboxes
  const items = document.querySelectorAll(`[data-type="${type}"]`);
  items.forEach(el => el.classList.toggle('on', filterState.nodeTypes[type]));

  applyFilters();
}

function toggleEdgeType(type, toggleEl) {
  filterState.edgeTypes[type] = !filterState.edgeTypes[type];
  toggleEl.classList.toggle('on', filterState.edgeTypes[type]);
  applyFilters();
}

function toggleValue(el, type, id) {
  const v = filterState.nodeValues[type][id];
  v.enabled = !v.enabled;
  el.classList.toggle('on', v.enabled);

  // Update type toggle if all on or all off
  const allVals = Object.values(filterState.nodeValues[type]);
  const anyOn = allVals.some(v => v.enabled);
  filterState.nodeTypes[type] = anyOn;
  const section = document.querySelector(`[data-section="node-${type}"]`);
  if (section) {
    const toggle = section.querySelector('.cp-toggle');
    if (toggle) toggle.classList.toggle('on', anyOn);
  }

  applyFilters();
}

function selectAllValues(type, enabled) {
  for (const id of Object.keys(filterState.nodeValues[type])) {
    filterState.nodeValues[type][id].enabled = enabled;
  }
  filterState.nodeTypes[type] = enabled;

  const items = document.querySelectorAll(`[data-type="${type}"]`);
  items.forEach(el => el.classList.toggle('on', enabled));

  const section = document.querySelector(`[data-section="node-${type}"]`);
  if (section) {
    const toggle = section.querySelector('.cp-toggle');
    if (toggle) toggle.classList.toggle('on', enabled);
  }

  applyFilters();
}

function filterValues(type, query) {
  const q = query.toLowerCase().trim();
  const items = document.querySelectorAll(`#values-${type} .cp-value-item`);
  items.forEach(el => {
    const label = el.querySelector('.cp-value-label').textContent.toLowerCase();
    const fullLabel = el.querySelector('.cp-value-label').title.toLowerCase();
    el.style.display = (!q || label.includes(q) || fullLabel.includes(q)) ? '' : 'none';
  });
}

// ── Brand / style helpers ───────────────────────────

function getBrandCode(node) {
  if (node.type === 'brand') {
    for (const [c, t] of Object.entries(BRAND_THEMES)) if (t.label === node.label) return c;
  }
  if (node.label) {
    for (const p of node.label.toLowerCase().split('/')) if (BRAND_THEMES[p]) return p;
  }
  if (graphData) {
    for (const e of graphData.edges) {
      const otherId = e.source === node.id ? e.target : (e.target === node.id ? e.source : null);
      if (!otherId) continue;
      const o = graphData.nodeMap[otherId];
      if (o?.type === 'document' && o.label) {
        for (const p of o.label.toLowerCase().split('/')) if (BRAND_THEMES[p]) return p;
      }
      if (o?.type === 'brand') {
        for (const [c, t] of Object.entries(BRAND_THEMES)) if (t.label === o.label) return c;
      }
    }
  }
  return null;
}

function getNodeStyle(node) {
  const code = getBrandCode(node);
  const theme = code ? BRAND_THEMES[code] : null;
  return (theme?.colors[node.type]) || DEFAULT_COLORS[node.type] || { bg: '#888', size: 14 };
}

function getEdgeColor(edge) {
  const src = graphData?.nodeMap[edge.source];
  if (src) {
    const code = getBrandCode(src);
    if (code && BRAND_THEMES[code]?.edges[edge.type]) return BRAND_THEMES[code].edges[edge.type];
  }
  return '#AAAAAA';
}

// ── Build network ───────────────────────────────────

function buildNetwork(data) {
  allVisNodes = data.nodes.map(n => {
    const s = getNodeStyle(n);
    const label = n.type === 'document' ? n.label.split('/').pop().replace('.pdf','') : n.label;
    return {
      id: n.id, label, origLabel: label, fullLabel: n.label, nodeType: n.type,
      shape: 'dot', size: s.size,
      color: { background: s.bg, border: s.bg, highlight: { background: MATCH_COLOR, border: '#fff' }, hover: { background: s.bg, border: '#333' } },
      font: { size: n.type==='brand'?16:n.type==='category'?14:11, color: '#333', face: 'Inter, sans-serif' },
      borderWidth: 2, chunkCount: n.chunkCount||0, degree: n.degree||0,
    };
  });

  visNodeById = {};
  allVisNodes.forEach(n => { visNodeById[n.id] = n; });

  allVisEdges = data.edges.map((e, i) => {
    const meta = EDGE_TYPE_META[e.type] || { label: e.type };
    return {
      id: 'e'+i, from: e.source, to: e.target, edgeType: e.type,
      label: meta.label,
      color: { color: getEdgeColor(e) },
      width: 0.5,
      font: { size: 8, color: '#999', strokeWidth: 2, strokeColor: '#fff', face: 'Inter, sans-serif' },
      smooth: { type: 'continuous' },
      arrows: { to: { enabled: false } },
    };
  });

  visNodes = new vis.DataSet(allVisNodes);
  visEdges = new vis.DataSet(allVisEdges);

  network = new vis.Network(document.getElementById('vis-canvas'),
    { nodes: visNodes, edges: visEdges },
    {
      nodes: { shape: 'dot', font: { size: 14 }, borderWidth: 2 },
      edges: { width: 0.5, smooth: { type: 'continuous' },
        font: { size: 11, color: '#777', strokeWidth: 3, strokeColor: '#F3F4F6', face: 'Inter, sans-serif', align: 'middle', background: 'rgba(243,244,246,0.85)' },
        scaling: { label: { enabled: true, min: 8, max: 14 } } },
      physics: {
        stabilization: false,
        barnesHut: { gravitationalConstant: -12000, centralGravity: 0.15, springLength: 200, springConstant: 0.01, damping: 0.5 },
      },
      interaction: { hover: true },
    }
  );

  network.on('click', params => {
    if (params.nodes.length > 0) {
      showTooltip(params.nodes[0], params.pointer.DOM.x, params.pointer.DOM.y);
    } else {
      hideTooltip();
      closeDocViewer();
    }
  });
  network.on('doubleClick', params => {
    if (params.nodes.length > 0) {
      const node = graphData.nodeMap[params.nodes[0]];
      if (node && node.meta && node.meta.url) {
        window.open(node.meta.url, '_blank');
      }
    }
  });
}

// ── Apply filters ───────────────────────────────────

function applyFilters() {
  // Cascade order: brand -> category -> document -> product/concept
  // Each level restricts the available set for the next level via graph edges.

  // 1. Get user-selected IDs per type
  const selected = {};
  for (const [type, values] of Object.entries(filterState.nodeValues)) {
    selected[type] = new Set();
    if (!filterState.nodeTypes[type]) continue;
    for (const [id, v] of Object.entries(values)) {
      if (v.enabled) selected[type].add(id);
    }
  }

  const allBrands = Object.keys(filterState.nodeValues.brand || {});
  const allCats = Object.keys(filterState.nodeValues.category || {});
  const brandFiltered = allBrands.length > 0 && selected.brand.size < allBrands.length;
  const catFiltered = allCats.length > 0 && selected.category.size < allCats.length;
  const anchorsFiltered = brandFiltered || catFiltered;

  // 2. Compute reachable documents from selected services + categories
  let reachableDocs = null;
  if (anchorsFiltered) {
    reachableDocs = new Set();
    const anchors = new Set([...(selected.brand || []), ...(selected.category || [])]);
    for (const anchorId of anchors) {
      const neighbors = adjacency[anchorId] || new Set();
      for (const nId of neighbors) {
        if (graphData.nodeMap[nId]?.type === 'document') reachableDocs.add(nId);
      }
    }
  }

  // 3. Visible documents = intersection of user selection and reachable
  const visibleDocs = new Set();
  for (const docId of (selected.document || [])) {
    if (!reachableDocs || reachableDocs.has(docId)) visibleDocs.add(docId);
  }

  // 4. Compute reachable entities from visible documents
  const reachableEntities = new Set();
  if (anchorsFiltered) {
    for (const docId of visibleDocs) {
      for (const nId of (adjacency[docId] || [])) {
        const n = graphData.nodeMap[nId];
        if (n && (n.type === 'product' || n.type === 'concept')) reachableEntities.add(nId);
      }
    }
  }

  // 5. Visible entities
  const visibleProducts = new Set();
  for (const id of (selected.product || [])) {
    if (!anchorsFiltered || reachableEntities.has(id)) visibleProducts.add(id);
  }
  const visibleConcepts = new Set();
  for (const id of (selected.concept || [])) {
    if (!anchorsFiltered || reachableEntities.has(id)) visibleConcepts.add(id);
  }

  // 6. Final sets — rendered (shown) vs edge-routing (for edge visibility)
  // Documents that are type-toggled off still act as edge routers so
  // relationships between services/categories and entities remain visible.
  const renderedNodeIds = new Set([
    ...(selected.brand || []),
    ...(selected.category || []),
    ...visibleDocs,
    ...visibleProducts,
    ...visibleConcepts,
  ]);

  // Edge-routing includes rendered nodes + documents that are reachable
  // but type-hidden (so edges through them still connect visible nodes)
  const docsTypeOff = !filterState.nodeTypes.document;
  const edgeRouteIds = new Set(renderedNodeIds);
  if (docsTypeOff && reachableDocs) {
    for (const id of reachableDocs) edgeRouteIds.add(id);
  } else if (docsTypeOff) {
    // No service filter active — all docs are potential routers
    for (const id of Object.keys(filterState.nodeValues.document || {})) edgeRouteIds.add(id);
  }

  // 7. Update graph nodes
  // Nodes in edgeRouteIds but not renderedNodeIds become invisible
  // (size 0, transparent) rather than hidden, so edges still route through them.
  visNodes.update(allVisNodes.map(n => {
    if (renderedNodeIds.has(n.id)) {
      // Restore original style in case it was previously an invisible router
      const s = getNodeStyle(graphData.nodeMap[n.id]);
      return { id: n.id, hidden: false, size: s.size, label: n.origLabel,
        color: { background: s.bg, border: s.bg,
          highlight: { background: MATCH_COLOR, border: '#fff' },
          hover: { background: s.bg, border: '#333' } },
        font: { size: n.nodeType==='brand'?16:n.nodeType==='category'?14:11,
          color: '#333', face: 'Inter, sans-serif' },
        borderWidth: 2, shadow: { enabled: false } };
    }
    if (edgeRouteIds.has(n.id)) {
      // Invisible router — present for edges but not visible to the user
      return { id: n.id, hidden: false, size: 0, label: '',
        color: { background: 'transparent', border: 'transparent' },
        font: { size: 0 }, borderWidth: 0, shadow: { enabled: false } };
    }
    return { id: n.id, hidden: true };
  }));

  // 8. Update graph edges — use edge-routing set so edges through hidden docs still show
  visEdges.update(allVisEdges.map(e => ({
    id: e.id,
    hidden: !filterState.edgeTypes[e.edgeType] || !edgeRouteIds.has(e.from) || !edgeRouteIds.has(e.to),
  })));

  // 9. Cascade filter panel — hide unavailable items in downstream sections
  if (anchorsFiltered) {
    // Update document checkboxes: dim unavailable ones
    const docItems = document.querySelectorAll('#values-document .cp-value-item');
    docItems.forEach(el => {
      const id = el.dataset.id;
      if (reachableDocs && !reachableDocs.has(id)) {
        el.classList.add('unavailable');
      } else {
        el.classList.remove('unavailable');
      }
    });
    // Update entity checkboxes
    for (const type of ['product', 'concept']) {
      const items = document.querySelectorAll(`#values-${type} .cp-value-item`);
      items.forEach(el => {
        if (!reachableEntities.has(el.dataset.id)) {
          el.classList.add('unavailable');
        } else {
          el.classList.remove('unavailable');
        }
      });
    }
    // Update category checkboxes when only brands filtered
    if (brandFiltered) {
      const reachableCats = new Set();
      for (const docId of reachableDocs) {
        for (const nId of (adjacency[docId] || [])) {
          if (graphData.nodeMap[nId]?.type === 'category') reachableCats.add(nId);
        }
      }
      const catItems = document.querySelectorAll('#values-category .cp-value-item');
      catItems.forEach(el => {
        if (!reachableCats.has(el.dataset.id)) {
          el.classList.add('unavailable');
        } else {
          el.classList.remove('unavailable');
        }
      });
    }
  } else {
    // Clear all unavailable markers
    document.querySelectorAll('.cp-value-item.unavailable').forEach(el => el.classList.remove('unavailable'));
  }

  // Update counts in section headers
  for (const type of ['brand','category','document','product','concept']) {
    const section = document.querySelector(`[data-section="node-${type}"]`);
    if (!section) continue;
    const countEl = section.querySelector('.cp-count');
    if (!countEl) continue;
    const total = Object.keys(filterState.nodeValues[type] || {}).length;
    const available = document.querySelectorAll(`#values-${type} .cp-value-item:not(.unavailable)`).length;
    countEl.textContent = anchorsFiltered && type !== 'brand' ? `${available}/${total}` : `${total}`;
  }

  updateStats();
}

function updateStats() {
  const visibleNodes = allVisNodes.filter(n => {
    const v = filterState.nodeValues[n.nodeType]?.[n.id];
    return filterState.nodeTypes[n.nodeType] && v?.enabled;
  }).length;
  const visibleEdges = allVisEdges.filter(e => {
    if (!filterState.edgeTypes[e.edgeType]) return false;
    const srcN = visNodeById[e.from];
    const tgtN = visNodeById[e.to];
    const srcV = filterState.nodeValues[srcN?.nodeType]?.[e.from];
    const tgtV = filterState.nodeValues[tgtN?.nodeType]?.[e.to];
    return srcV?.enabled && tgtV?.enabled;
  }).length;
  document.getElementById('cp-stats').textContent = `${visibleNodes}n · ${visibleEdges}e`;
}

// ── Tooltip ─────────────────────────────────────────

function showTooltip(nodeId, x, y) {
  const node = graphData.nodeMap[nodeId];
  if (!node) return;

  // Document nodes open the doc viewer panel
  if (node.type === 'document') {
    hideTooltip();
    openDocViewer(nodeId, node);
    return;
  }

  const code = getBrandCode(node);
  const theme = code ? BRAND_THEMES[code] : null;
  document.documentElement.style.setProperty('--tt-primary', theme?.primary || '#555');
  document.documentElement.style.setProperty('--tt-secondary', theme?.secondary || '#777');

  const tip = document.getElementById('node-tooltip');
  tip.textContent = node.type + ': ' + node.label;
  tip.style.left = (x + 10) + 'px';
  tip.style.top = (y + 10) + 'px';
  tip.style.display = 'inline';
  clearTimeout(tooltipTimer);
  tooltipTimer = setTimeout(hideTooltip, 3000);
}

let tooltipTimer = null;
function hideTooltip() { clearTimeout(tooltipTimer); document.getElementById('node-tooltip').style.display = 'none'; }

// ── Document Viewer ──────────────────────────────────

async function openDocViewer(nodeId, node) {
  const viewer = document.getElementById('doc-viewer');
  const title = node.meta?.title || node.label;
  document.getElementById('doc-viewer-title').textContent = title;

  const urlEl = document.getElementById('doc-viewer-url');
  urlEl.innerHTML = '';
  if (node.meta?.url) {
    const a = document.createElement('a');
    a.href = node.meta.url;
    a.target = '_blank';
    a.textContent = node.meta.url + ' \u2197';
    urlEl.appendChild(a);
  }

  const vn = allVisNodes.find(n => n.id === nodeId);
  document.getElementById('doc-viewer-meta').textContent = node.label + (vn?.chunkCount ? ` · ${vn.chunkCount} chunks` : '');

  document.getElementById('doc-viewer-body').innerHTML = '<div class="doc-viewer-loading">Loading...</div>';
  viewer.classList.add('visible');

  // Extract file path from doc node id (strip "doc:" prefix)
  const file = nodeId.startsWith('doc:') ? nodeId.slice(4) : node.label;
  try {
    const resp = await fetch('/api/document?file=' + encodeURIComponent(file));
    const data = await resp.json();
    if (data.error) {
      document.getElementById('doc-viewer-body').innerHTML = `<div class="doc-viewer-loading">${data.error}</div>`;
      return;
    }
    const html = renderMarkdown(data.text);
    document.getElementById('doc-viewer-body').innerHTML = `<p>${html}</p>`;
  } catch (e) {
    document.getElementById('doc-viewer-body').innerHTML = `<div class="doc-viewer-loading">Failed to load: ${e.message}</div>`;
  }
}

function closeDocViewer() {
  document.getElementById('doc-viewer').classList.remove('visible');
}

// ── Memory Graph + Viewer ────────────────────────────

let memoryGraphActive = false;
let memoryNetwork = null;
let cachedMemories = null;

async function toggleMemoryGraph() {
  const btn = document.getElementById('cp-memory-btn');
  if (memoryGraphActive) {
    exitMemoryGraph();
    btn.classList.remove('active');
    return;
  }
  btn.classList.add('active');
  memoryGraphActive = true;

  // Hide knowledge graph elements, show loading
  if (network) { network.destroy(); network = null; }
  closeDocViewer();
  closeMemoryViewer();

  try {
    const resp = await fetch('/api/memory');
    const data = await resp.json();
    cachedMemories = data.memories || [];

    if (cachedMemories.length === 0) {
      document.getElementById('vis-canvas').innerHTML =
        '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#999;font-size:14px;font-family:Inter,sans-serif;">No conversation memory yet</div>';
      return;
    }

    buildMemoryNetwork(cachedMemories);
  } catch (e) {
    document.getElementById('vis-canvas').innerHTML =
      '<div style="display:flex;align-items:center;justify-content:center;height:100%;color:#999;font-size:14px;font-family:Inter,sans-serif;">Failed to load memory: ' + e.message + '</div>';
  }
}

function exitMemoryGraph() {
  memoryGraphActive = false;
  if (memoryNetwork) { memoryNetwork.destroy(); memoryNetwork = null; }
  closeMemoryViewer();
  // Rebuild the knowledge graph
  document.getElementById('vis-canvas').innerHTML = '';
  buildNetwork(graphData);
  applyFilters();
}

function buildMemoryNetwork(memories) {
  const nodes = [];
  const edges = [];
  const sourceMap = {}; // file -> node id

  // Sort chronologically
  memories.sort((a, b) => new Date(a.timestamp || 0) - new Date(b.timestamp || 0));

  // Create memory nodes
  memories.forEach((m, i) => {
    const truncQ = (m.query || '').length > 50 ? (m.query || '').slice(0, 47) + '...' : (m.query || '');
    nodes.push({
      id: m.id,
      label: truncQ,
      shape: 'dot',
      size: 30,
      color: { background: '#f0a030', border: '#d48820', highlight: { background: '#ffc060', border: '#fff' }, hover: { background: '#f0a030', border: '#333' } },
      font: { size: 12, color: '#333', face: 'Inter, sans-serif', multi: 'html' },
      borderWidth: 2,
      shadow: { enabled: true, color: 'rgba(240,160,48,0.3)', size: 8, x: 0, y: 0 },
      memoryData: m,
      nodeType: 'memory',
    });

    // Chronological edge to previous memory
    if (i > 0) {
      edges.push({
        id: 'follows-' + i,
        from: memories[i - 1].id,
        to: m.id,
        label: 'follows',
        color: { color: '#ccc' },
        width: 1.5,
        dashes: [6, 4],
        arrows: { to: { enabled: true, scaleFactor: 0.5 } },
        font: { size: 9, color: '#bbb', strokeWidth: 2, strokeColor: '#fff', face: 'Inter, sans-serif' },
        smooth: { type: 'curvedCW', roundness: 0.1 },
        edgeType: 'follows',
      });
    }

    // Source nodes + citation edges
    const srcFiles = new Set();
    (m.sources || []).forEach(s => {
      const file = typeof s === 'string' ? s : (s.file || '');
      if (!file || srcFiles.has(file)) return;
      srcFiles.add(file);

      if (!sourceMap[file]) {
        const shortName = file.split('/').pop().replace(/\.(pdf|md)$/i, '');
        const srcId = 'src:' + file;
        sourceMap[file] = srcId;
        nodes.push({
          id: srcId,
          label: shortName,
          shape: 'dot',
          size: 14,
          color: { background: '#4a8eda', border: '#3a7bd5', highlight: { background: '#6ab0ff', border: '#fff' }, hover: { background: '#4a8eda', border: '#333' } },
          font: { size: 10, color: '#666', face: 'Inter, sans-serif' },
          borderWidth: 1,
          nodeType: 'source',
        });
      }

      edges.push({
        id: 'cites-' + m.id + '-' + file,
        from: m.id,
        to: sourceMap[file],
        label: 'cites',
        color: { color: '#e8a84c' },
        width: 0.8,
        font: { size: 8, color: '#ccc', strokeWidth: 2, strokeColor: '#fff', face: 'Inter, sans-serif' },
        smooth: { type: 'continuous' },
        arrows: { to: { enabled: true, scaleFactor: 0.4 } },
        edgeType: 'cites',
      });
    });
  });

  // Related edges — memories sharing sources
  for (let i = 0; i < memories.length; i++) {
    const srcA = new Set((memories[i].sources || []).map(s => typeof s === 'string' ? s : (s.file || '')).filter(Boolean));
    for (let j = i + 1; j < memories.length; j++) {
      const srcB = new Set((memories[j].sources || []).map(s => typeof s === 'string' ? s : (s.file || '')).filter(Boolean));
      const shared = [...srcA].filter(f => srcB.has(f));
      if (shared.length > 0) {
        edges.push({
          id: 'related-' + i + '-' + j,
          from: memories[i].id,
          to: memories[j].id,
          label: shared.length + ' shared',
          color: { color: '#b07de8' },
          width: Math.min(shared.length, 4),
          font: { size: 8, color: '#b07de8', strokeWidth: 2, strokeColor: '#fff', face: 'Inter, sans-serif' },
          smooth: { type: 'curvedCCW', roundness: 0.2 },
          dashes: false,
          edgeType: 'related',
        });
      }
    }
  }

  document.getElementById('vis-canvas').innerHTML = '';
  const visMemNodes = new vis.DataSet(nodes);
  const visMemEdges = new vis.DataSet(edges);

  memoryNetwork = new vis.Network(document.getElementById('vis-canvas'),
    { nodes: visMemNodes, edges: visMemEdges },
    {
      nodes: { shape: 'dot', font: { size: 12 }, borderWidth: 2 },
      edges: { width: 0.8, smooth: { type: 'continuous' },
        font: { size: 9, color: '#999', strokeWidth: 2, strokeColor: '#F3F4F6', face: 'Inter, sans-serif', align: 'middle', background: 'rgba(243,244,246,0.85)' },
      },
      physics: {
        stabilization: { iterations: 150 },
        barnesHut: { gravitationalConstant: -8000, centralGravity: 0.2, springLength: 180, springConstant: 0.02, damping: 0.4 },
      },
      interaction: { hover: true },
    }
  );

  // Click memory node → open detail panel
  memoryNetwork.on('click', params => {
    if (params.nodes.length > 0) {
      const nodeId = params.nodes[0];
      const node = visMemNodes.get(nodeId);
      if (node?.nodeType === 'memory' && node.memoryData) {
        openMemoryDetail(node.memoryData);
      } else if (node?.nodeType === 'source') {
        // Show source name tooltip
        const tip = document.getElementById('node-tooltip');
        tip.textContent = 'Source: ' + node.label;
        tip.style.left = (params.pointer.DOM.x + 10) + 'px';
        tip.style.top = (params.pointer.DOM.y + 10) + 'px';
        tip.style.display = 'inline';
        clearTimeout(tooltipTimer);
        tooltipTimer = setTimeout(hideTooltip, 3000);
      }
    } else {
      hideTooltip();
      closeMemoryViewer();
    }
  });

  // Update stats
  document.getElementById('cp-stats').textContent = nodes.length + 'n · ' + edges.length + 'e';
}

function openMemoryDetail(m) {
  const viewer = document.getElementById('memory-viewer');
  const body = document.getElementById('memory-viewer-body');
  document.getElementById('memory-count').textContent = new Date(m.timestamp).toLocaleString();

  const answer = renderMarkdown(m.answer || '');
  const sources = (m.sources || []).map(s => {
    const label = typeof s === 'string' ? s : (s.file || s.title || 'source');
    return '<span>' + label.replace(/&/g,'&amp;').replace(/</g,'&lt;') + '</span>';
  }).join(' ');

  body.innerHTML = '<div class="memory-card">'
    + '<div class="memory-card-q">Q: ' + (m.query||'').replace(/&/g,'&amp;').replace(/</g,'&lt;') + '</div>'
    + '<div class="memory-card-a"><p>' + answer + '</p></div>'
    + (sources ? '<div class="memory-card-sources">Sources: ' + sources + '</div>' : '')
    + '</div>';

  viewer.classList.add('visible');
}

async function openMemoryViewer() {
  const viewer = document.getElementById('memory-viewer');
  const body = document.getElementById('memory-viewer-body');
  body.innerHTML = '<div class="doc-viewer-loading">Loading...</div>';
  viewer.classList.add('visible');

  try {
    const memories = cachedMemories || (await (await fetch('/api/memory')).json()).memories || [];
    document.getElementById('memory-count').textContent = memories.length + ' interaction' + (memories.length !== 1 ? 's' : '');

    if (memories.length === 0) {
      body.innerHTML = '<div class="doc-viewer-loading">No conversation memory yet</div>';
      return;
    }

    body.innerHTML = memories.map(m => {
      const time = m.timestamp ? new Date(m.timestamp).toLocaleString() : '';
      const answer = renderMarkdown(m.answer || '');
      const sources = (m.sources || []).map(s => {
        const label = typeof s === 'string' ? s : (s.file || s.title || 'source');
        return '<span>' + label.replace(/&/g,'&amp;').replace(/</g,'&lt;') + '</span>';
      }).join(' ');
      return '<div class="memory-card">'
        + (time ? '<div class="memory-card-time">' + time + '</div>' : '')
        + '<div class="memory-card-q">Q: ' + (m.query||'').replace(/&/g,'&amp;').replace(/</g,'&lt;') + '</div>'
        + '<div class="memory-card-a"><p>' + answer + '</p></div>'
        + (sources ? '<div class="memory-card-sources">Sources: ' + sources + '</div>' : '')
        + '</div>';
    }).join('');
  } catch (e) {
    body.innerHTML = '<div class="doc-viewer-loading">Failed to load: ' + e.message + '</div>';
  }
}

function closeMemoryViewer() {
  document.getElementById('memory-viewer').classList.remove('visible');
}

// ── Path Highlighting ───────────────────────────────

function highlightPath(pathData) {
  if (!graphData || !pathData || !network) return;
  const pn = new Set(pathData.nodes);
  const pe = new Set();
  pathData.edges.forEach(e => { pe.add(e.source+'|'+e.target); pe.add(e.target+'|'+e.source); });
  matchedDocIds = new Set(pathData.nodes.filter(id => graphData.nodeMap[id]?.type === 'document'));

  // Hide all unrelated nodes, show only path-relevant ones
  visNodes.update(allVisNodes.map(n => {
    if (pn.has(n.id)) {
      const s = getNodeStyle(graphData.nodeMap[n.id]);
      const isDoc = n.nodeType === 'document';
      return { id:n.id, hidden:false, size: isDoc?s.size*2:s.size*1.2,
        color: { background: isDoc?MATCH_COLOR:s.bg, border: isDoc?'#fff':s.bg, highlight:{background:MATCH_COLOR,border:'#fff'} },
        font: { size:n.nodeType==='brand'?18:n.nodeType==='category'?16:13, color:'#111', face:'Inter, sans-serif', bold:true },
        borderWidth:3, shadow:{enabled:true,color:isDoc?MATCH_COLOR:s.bg,size:12,x:0,y:0} };
    }
    return { id:n.id, hidden:true };
  }));

  // Hide all unrelated edges, show only path edges
  visEdges.update(allVisEdges.map(e => {
    if (pe.has(e.from+'|'+e.to)) {
      return { id:e.id, hidden:false, color:{color:MATCH_COLOR}, width:2, shadow:{enabled:true,color:MATCH_COLOR,size:6,x:0,y:0} };
    }
    return { id:e.id, hidden:true };
  }));

  const pathIds = pathData.nodes.filter(id => visNodes.get(id));
  if (pathIds.length) network.fit({ nodes:pathIds, animation:{duration:800,easingFunction:'easeInOutQuad'} });
}

function clearPath() {
  if (!network) return;
  matchedDocIds.clear();
  visNodes.update(allVisNodes.map(n => {
    const s=getNodeStyle(graphData.nodeMap[n.id]);
    return { id:n.id, hidden:false, size:s.size,
      color:{background:s.bg,border:s.bg,highlight:{background:MATCH_COLOR,border:'#fff'},hover:{background:s.bg,border:'#333'}},
      font:{size:n.nodeType==='brand'?16:n.nodeType==='category'?14:11,color:'#333',face:'Inter, sans-serif',bold:false},
      borderWidth:2, shadow:{enabled:false} };
  }));
  visEdges.update(allVisEdges.map(e => ({
    id:e.id, hidden:false, color:{color:getEdgeColor({source:e.from,target:e.to,type:e.edgeType})},
    width:0.5, shadow:{enabled:false} })));
  applyFilters();
  network.fit({animation:{duration:500}});
}

function focusNode(nodeId) {
  if (!network||!graphData?.nodeMap[nodeId]) return;
  network.focus(nodeId,{scale:1.5,animation:{duration:600,easingFunction:'easeInOutQuad'}});
  const pos=network.getPosition(nodeId);
  const domPos=network.canvasToDOM(pos);
  showTooltip(nodeId,domPos.x,domPos.y);
}

// ── Shared markdown renderer ────────────────────────

function renderMarkdown(text) {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/^### (.+)$/gm, '<h3>$1</h3>')
    .replace(/^## (.+)$/gm, '<h2>$1</h2>')
    .replace(/^# (.+)$/gm, '<h1>$1</h1>')
    .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
    .replace(/\[Source (\d+)\]/g, '<strong style="color:#e67e22">[Source $1]</strong>')
    .replace(/^[-*] (.+)$/gm, '<li>$1</li>')
    .replace(/\n\n/g, '</p><p>')
    .replace(/\n/g, '<br>');
}

// ── Entry ───────────────────────────────────────────
async function tryLoadData() {
  document.getElementById('loading').querySelector('.loading-text').textContent='Start server: node search.js serve';
}
tryLoadData();
</script>
</body>
</html>
